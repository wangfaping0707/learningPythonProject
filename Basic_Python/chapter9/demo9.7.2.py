"""
彻底理解 Python 生成器:
1. 生成器定义
在Python中，一边循环一边计算的机制，称为生成器：generator。
2. 为什么要有生成器?
列表所有数据都在内存中，如果有海量数据的话将会非常耗内存。
如：仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。
如果列表元素按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。
简单一句话：我又想要得到庞大的数据，又想让它占用空间少，那就用生成器！

3.如何创建生成器?

第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：
创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。
"""
L = [x*x for x in range(0, 10)]
print(L)

g = (y*y for y in range(0,10))
print(type(g),g)
print("------------------------------分割线-----------------------------")
"""
方法二， 如果一个函数中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。调用函数就是创建了一个生成器（generator）对象。
4. 生成器的工作原理
（1）生成器(generator)能够迭代的关键是它有一个next()方法，
　　工作原理就是通过重复调用next()方法，直到捕获一个异常。

（2）带有 yield 的函数不再是一个普通函数，而是一个生成器generator。
　　可用next()调用生成器对象来取值。next 两种方式 t.__next__()  |  next(t)。
　　可用for 循环获取返回值（每执行一次，取生成器里面一个值）
　　（基本上不会用next()来获取下一个返回值，而是直接使用for循环来迭代）。
（3）yield相当于 return 返回一个值，并且记住这个返回的位置，下次迭代时，代码从yield的下一条语句开始执行。
（4）.send() 和next()一样，都能让生成器继续往下走一步（下次遇到yield停），但send()能传一个值，这个值作为yield表达式整体的结果

—————————— 换句话说，就是send可以强行修改上一个yield表达式值。比如函数中有一个yield赋值，a = yield 5，第一次迭代到这里会返回5，a还没有赋值。
第二次迭代时，使用.send(10)，那么，就是强行修改yield 5表达式的值为10，本来是5的，那么a=10

感受下yield返回值的过程（关注点：每次停在哪，下次又开始在哪）及send()传参的通讯过程
"""
def yield_test(n):
    for i in range(n):
        yield call(i)
        print("i=", i)
    print("Done.")



def call(i):
    return i * 2



for i in yield_test(5):
    print("hello",i, ",")

# 理解的关键在于：下次迭代时，代码从yield的下一条语句开始执行。

"""
总结：
什么是生成器？
生成器仅仅保存了一套生成数值的算法，并且没有让这个算法现在就开始执行，而是我什么时候调它，它什么时候开始计算一个新的值，并给你返回。"""



























